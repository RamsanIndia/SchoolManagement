name: $(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
      - master
  paths:
    exclude:
      - README.md
      - docs/*

pr:
  branches:
    include:
      - master

variables:
  - group: school-app-variables
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '8.0.x'
  - name: nodeVersion
    value: '20.x'
  - name: apiPath
    value: 'SchoolManagement.API'
  - name: uiPath
    value: 'SchoolManagement.UI'

stages:
  ###########################################
  # STAGE 1: BUILD
  ###########################################
  - stage: Build
    displayName: 'Build Application'
    jobs:
      - job: BuildAPI
        displayName: 'Build .NET Core 8 API'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: UseDotNet@2
            displayName: 'Install .NET Core SDK $(dotnetVersion)'
            inputs:
              version: $(dotnetVersion)
              packageType: sdk
          
          - bash: |
              dotnet --version
              dotnet --list-sdks
            displayName: 'Display .NET Version'
          
          - task: DotNetCoreCLI@2
            displayName: 'Restore NuGet Packages'
            inputs:
              command: 'restore'
              projects: '$(apiPath)/**/*.csproj'
              feedsToUse: 'select'
          
          - task: DotNetCoreCLI@2
            displayName: 'Build API Project'
            inputs:
              command: 'build'
              projects: '$(apiPath)/**/*.csproj'
              arguments: '--configuration $(buildConfiguration) --no-restore'
          
          - task: DotNetCoreCLI@2
            displayName: 'Run API Unit Tests'
            inputs:
              command: 'test'
              projects: '**/*Tests/*.csproj'
              arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --logger trx --results-directory $(Agent.TempDirectory)/TestResults'
              publishTestResults: false
            continueOnError: true
            condition: succeededOrFailed()
          
          - task: PublishTestResults@2
            displayName: 'Publish API Test Results'
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: '$(Agent.TempDirectory)/TestResults/**/*.trx'
              mergeTestResults: true
              failTaskOnFailedTests: false
              testRunTitle: 'API Tests'
            condition: succeededOrFailed()
          
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish API Code Coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Agent.TempDirectory)/TestResults/**/coverage.cobertura.xml'
              failIfCoverageEmpty: false
            condition: succeededOrFailed()
          
          - task: DotNetCoreCLI@2
            displayName: 'Publish API'
            inputs:
              command: 'publish'
              publishWebProjects: false
              projects: '$(apiPath)/**/*.csproj'
              arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/api --no-restore'
              zipAfterPublish: true
              modifyOutputPath: false
          
          - publish: $(Build.ArtifactStagingDirectory)/api
            artifact: api-drop
            displayName: 'Publish API Artifacts'
      
      - job: BuildUI
        displayName: 'Build React TypeScript UI'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js $(nodeVersion)'
            inputs:
              versionSpec: $(nodeVersion)
          
          - bash: |
              node --version
              npm --version
            displayName: 'Display Node.js and npm versions'
          
          - task: Cache@2
            displayName: 'Cache npm packages'
            inputs:
              key: 'npm | "$(Agent.OS)" | $(uiPath)/package-lock.json'
              path: '$(uiPath)/node_modules'
              restoreKeys: |
                npm | "$(Agent.OS)"
              cacheHitVar: 'CACHE_RESTORED'
          
          - bash: |
              cd $(Build.SourcesDirectory)/$(uiPath)
              echo "Installing dependencies..."
              npm ci --prefer-offline
            displayName: 'Install UI Dependencies'
          
          - bash: |
              cd $(Build.SourcesDirectory)/$(uiPath)
              if grep -q '"lint"' package.json; then
                npm run lint
              else
                echo "##[warning]No lint script found - skipping"
              fi
            displayName: 'Run ESLint'
            continueOnError: true
          
          - bash: |
              cd $(Build.SourcesDirectory)/$(uiPath)
              npx tsc --noEmit
            displayName: 'TypeScript Type Check'
            continueOnError: true
          
          - bash: |
              cd $(Build.SourcesDirectory)/$(uiPath)
              if grep -q '"test"' package.json; then
                echo "Running tests..."
                npm test -- --coverage --watchAll=false --ci --reporters=default --reporters=jest-junit || true
              else
                echo "##[warning]No test script found in package.json - skipping tests"
              fi
            displayName: 'Run UI Tests'
            continueOnError: true
            condition: succeededOrFailed()
            env:
              CI: true
          
          - task: PublishTestResults@2
            displayName: 'Publish UI Test Results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '$(Build.SourcesDirectory)/$(uiPath)/junit.xml'
              mergeTestResults: true
              failTaskOnFailedTests: false
              testRunTitle: 'UI Tests'
            continueOnError: true
            condition: succeededOrFailed()
          
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish UI Code Coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Build.SourcesDirectory)/$(uiPath)/coverage/cobertura-coverage.xml'
              reportDirectory: '$(Build.SourcesDirectory)/$(uiPath)/coverage'
              failIfCoverageEmpty: false
            continueOnError: true
            condition: succeededOrFailed()
          
          - bash: |
              cd $(Build.SourcesDirectory)/$(uiPath)
              echo "Running npm run build..."
              npm run build
              
              echo "Checking for output folders..."
              if [ -d "build" ]; then
                echo "##vso[task.setvariable variable=buildOutputFolder]build"
                echo "✓ Found 'build' folder (Create React App)"
                ls -lah build/ | head -20
              elif [ -d "dist" ]; then
                echo "##vso[task.setvariable variable=buildOutputFolder]dist"
                echo "✓ Found 'dist' folder (Vite)"
                ls -lah dist/ | head -20
              else
                echo "##[error]No build output folder found!"
                ls -lah
                exit 1
              fi
            displayName: 'Build React UI'
            env:
              CI: false
              GENERATE_SOURCEMAP: false
              NODE_ENV: production
          
          - task: ArchiveFiles@2
            displayName: 'Archive UI Build'
            inputs:
              rootFolderOrFile: '$(Build.SourcesDirectory)/$(uiPath)/$(buildOutputFolder)'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/ui-build.zip'
              replaceExistingArchive: true
          
          - publish: $(Build.ArtifactStagingDirectory)/ui-build.zip
            artifact: ui-drop
            displayName: 'Publish UI Artifacts'

  ###########################################
  # STAGE 2: DEPLOY TO DEVELOPMENT
  ###########################################
  - stage: DeployDevelopment
    displayName: 'Deploy to Development'
    dependsOn: Build
    condition: succeeded()
    variables:
      - name: apiWebAppName
        value: $(DEV_API_WEBAPP_NAME)
      - name: uiWebAppName
        value: $(DEV_UI_WEBAPP_NAME)
      - name: resourceGroup
        value: $(DEV_RESOURCE_GROUP)
      - name: databaseServer
        value: $(DEV_DATABASE_SERVER)
      - name: dbUsername
        value: $(DEV_DB_USERNAME)
      - name: dbPassword
        value: $(DEV_DB_PASSWORD)
      - name: appInsightsConnectionString
        value: $(DEV_APPINSIGHTS_CONNECTION_STRING)
      - name: aspnetEnvironment
        value: 'Development'
    
    jobs:
      - deployment: DeployDevAPI
        displayName: 'Deploy API to Development'
        environment: 'development'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: api-drop
                  displayName: 'Download API Artifacts'
                
                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy API to Azure App Service'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    appType: 'webAppLinux'
                    WebAppName: '$(apiWebAppName)'
                    packageForLinux: '$(Pipeline.Workspace)/api-drop/**/*.zip'
                    RuntimeStack: 'DOTNETCORE|8.0'
                
                - task: AzureAppServiceSettings@1
                  displayName: 'Configure API App Settings'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    appName: '$(apiWebAppName)'
                    resourceGroupName: '$(resourceGroup)'
                    appSettings: |
                      [
                        {
                          "name": "ASPNETCORE_ENVIRONMENT",
                          "value": "$(aspnetEnvironment)",
                          "slotSetting": false
                        },
                        {
                          "name": "ConnectionStrings__DefaultConnection",
                          "value": "Server=$(databaseServer).database.windows.net;Database=SchoolDB;User Id=$(dbUsername);Password=$(dbPassword);",
                          "slotSetting": false
                        },
                        {
                          "name": "APPLICATIONINSIGHTS_CONNECTION_STRING",
                          "value": "$(appInsightsConnectionString)",
                          "slotSetting": false
                        },
                        {
                          "name": "AllowedOrigins",
                          "value": "https://$(uiWebAppName).azurewebsites.net",
                          "slotSetting": false
                        }
                      ]
                
                - bash: |
                    echo "Waiting 60 seconds for API to fully start..."
                    sleep 60
                  displayName: 'Wait for API to Start'
                
                - task: AzureCLI@2
                  displayName: 'Check App Service Status'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Checking App Service status..."
                      az webapp show \
                        --name $(apiWebAppName) \
                        --resource-group $(resourceGroup) \
                        --query "{name:name, state:state, hostNames:defaultHostName}" \
                        -o table
                      
                      STATE=$(az webapp show \
                        --name $(apiWebAppName) \
                        --resource-group $(resourceGroup) \
                        --query "state" -o tsv)
                      
                      echo "App State: $STATE"
                      
                      if [ "$STATE" != "Running" ]; then
                        echo "⚠️ Warning: App is not in Running state!"
                      else
                        echo "✅ App is running"
                      fi
                  continueOnError: true
                
                - bash: |
                    echo "========================================"
                    echo "Development API Health Check"
                    echo "========================================"
                    
                    API_URL="https://$(apiWebAppName).azurewebsites.net"
                    HEALTH_URL="$API_URL/health"
                    
                    echo "API URL: $API_URL"
                    echo "Health Endpoint: $HEALTH_URL"
                    echo ""
                    
                    # First check if app is accessible at all
                    echo "1. Testing root endpoint..."
                    ROOT_CODE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 $API_URL)
                    echo "   Root status code: $ROOT_CODE"
                    
                    if [ "$ROOT_CODE" = "000" ]; then
                      echo "   ❌ Cannot connect to API at all!"
                      echo "   This usually means:"
                      echo "   - App failed to start"
                      echo "   - Wrong app name"
                      echo "   - Deployment failed"
                      echo ""
                      echo "   Checking Azure status..."
                      exit 1
                    fi
                    
                    echo "   ✅ API is accessible (Status: $ROOT_CODE)"
                    echo ""
                    
                    # Try health endpoint
                    echo "2. Testing /health endpoint..."
                    sleep 15
                    
                    MAX_ATTEMPTS=8
                    ATTEMPT=1
                    WAIT_BETWEEN_ATTEMPTS=10
                    
                    while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
                      echo ""
                      echo "   Attempt $ATTEMPT/$MAX_ATTEMPTS..."
                      
                      HEALTH_CODE=$(curl -s -o /tmp/health_dev.txt -w "%{http_code}" -m 10 $HEALTH_URL)
                      echo "   Status: $HEALTH_CODE"
                      
                      if [ $HEALTH_CODE -eq 200 ]; then
                        echo "   ✅ Health check passed!"
                        if [ -f /tmp/health_dev.txt ]; then
                          RESPONSE=$(cat /tmp/health_dev.txt)
                          echo "   Response: $RESPONSE"
                        fi
                        exit 0
                      fi
                      
                      if [ $HEALTH_CODE -eq 404 ]; then
                        echo "   ⚠️ /health endpoint not found (404)"
                        echo "   ℹ️  If you don't have a health endpoint, this is expected"
                        echo "   ✅ API root is accessible, continuing..."
                        exit 0
                      fi
                      
                      if [ "$HEALTH_CODE" = "000" ]; then
                        echo "   ⚠️ Connection failed - checking root again..."
                        ROOT_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -m 10 $API_URL)
                        if [ "$ROOT_CHECK" != "000" ]; then
                          echo "   ℹ️  Root is accessible ($ROOT_CHECK), health endpoint may not exist"
                          if [ $ATTEMPT -ge 4 ]; then
                            echo "   ✅ Continuing - API is responding"
                            exit 0
                          fi
                        fi
                      fi
                      
                      if [ $HEALTH_CODE -eq 503 ]; then
                        echo "   ⚠️ Service Unavailable (503) - app starting up"
                      fi
                      
                      if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                        echo "   ⏳ Waiting $WAIT_BETWEEN_ATTEMPTS seconds..."
                        sleep $WAIT_BETWEEN_ATTEMPTS
                      fi
                      
                      ATTEMPT=$((ATTEMPT + 1))
                    done
                    
                    echo ""
                    echo "⚠️ Health endpoint not responding with 200 after $MAX_ATTEMPTS attempts"
                    echo "But API root is accessible, so continuing with deployment"
                    echo ""
                    exit 0
                  displayName: 'API Health Check'
                  continueOnError: true
      
      - deployment: DeployDevUI
        displayName: 'Deploy UI to Development'
        dependsOn: DeployDevAPI
        condition: succeeded()
        environment: 'development'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: ui-drop
                  displayName: 'Download UI Artifacts'
                
                - task: ExtractFiles@1
                  displayName: 'Extract UI Build'
                  inputs:
                    archiveFilePatterns: '$(Pipeline.Workspace)/ui-drop/ui-build.zip'
                    destinationFolder: '$(Pipeline.Workspace)/ui-extracted'
                    cleanDestinationFolder: true
                
                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy UI to Azure App Service'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    appType: 'webAppLinux'
                    WebAppName: '$(uiWebAppName)'
                    packageForLinux: '$(Pipeline.Workspace)/ui-extracted'
                    RuntimeStack: 'NODE|18-lts'
                
                - task: AzureAppServiceSettings@1
                  displayName: 'Configure UI App Settings'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    appName: '$(uiWebAppName)'
                    resourceGroupName: '$(resourceGroup)'
                    appSettings: |
                      [
                        {
                          "name": "REACT_APP_API_URL",
                          "value": "https://$(apiWebAppName).azurewebsites.net",
                          "slotSetting": false
                        },
                        {
                          "name": "WEBSITE_NODE_DEFAULT_VERSION",
                          "value": "~18",
                          "slotSetting": false
                        }
                      ]
                
                - bash: |
                    echo "✅ Development Deployment Complete!"
                    echo "API: https://$(apiWebAppName).azurewebsites.net"
                    echo "UI: https://$(uiWebAppName).azurewebsites.net"
                  displayName: 'Deployment Summary'

  ###########################################
  # STAGE 3: DEPLOY TO PRODUCTION
  ###########################################
  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: DeployDevelopment
    condition: succeeded()
    variables:
      - name: apiWebAppName
        value: $(PROD_API_WEBAPP_NAME)
      - name: uiWebAppName
        value: $(PROD_UI_WEBAPP_NAME)
      - name: resourceGroup
        value: $(PROD_RESOURCE_GROUP)
      - name: databaseServer
        value: $(PROD_DATABASE_SERVER)
      - name: dbUsername
        value: $(PROD_DB_USERNAME)
      - name: dbPassword
        value: $(PROD_DB_PASSWORD)
      - name: appInsightsConnectionString
        value: $(PROD_APPINSIGHTS_CONNECTION_STRING)
      - name: storageAccount
        value: $(PROD_STORAGE_ACCOUNT)
      - name: storageKey
        value: $(PROD_STORAGE_KEY)
      - name: aspnetEnvironment
        value: 'Production'
    
    jobs:
      - deployment: DeployProdAPI
        displayName: 'Deploy API to Production'
        environment: 'production'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            preDeploy:
              steps:
                - task: AzureCLI@2
                  displayName: 'Backup Production Database'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      DATE=$(date +%Y%m%d_%H%M%S)
                      BACKUP_NAME="api_backup_$DATE"
                      echo "Creating database backup: $BACKUP_NAME"
                      az sql db export \
                        --resource-group $(resourceGroup) \
                        --server $(databaseServer) \
                        --name SchoolDB \
                        --admin-user $(dbUsername) \
                        --admin-password $(dbPassword) \
                        --storage-key-type StorageAccessKey \
                        --storage-key $(storageKey) \
                        --storage-uri "https://$(storageAccount).blob.core.windows.net/backups/$BACKUP_NAME.bacpac" \
                      && echo "✅ Backup completed" \
                      || echo "⚠️ Backup failed, continuing..."
                  continueOnError: true
            
            deploy:
              steps:
                - download: current
                  artifact: api-drop
                  displayName: 'Download API Artifacts'
                
                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy API to Azure App Service'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    appType: 'webAppLinux'
                    WebAppName: '$(apiWebAppName)'
                    packageForLinux: '$(Pipeline.Workspace)/api-drop/**/*.zip'
                    RuntimeStack: 'DOTNETCORE|8.0'
                
                - task: AzureAppServiceSettings@1
                  displayName: 'Configure API App Settings'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    appName: '$(apiWebAppName)'
                    resourceGroupName: '$(resourceGroup)'
                    appSettings: |
                      [
                        {
                          "name": "ASPNETCORE_ENVIRONMENT",
                          "value": "$(aspnetEnvironment)",
                          "slotSetting": false
                        },
                        {
                          "name": "ConnectionStrings__DefaultConnection",
                          "value": "Server=$(databaseServer).database.windows.net;Database=SchoolDB;User Id=$(dbUsername);Password=$(dbPassword);",
                          "slotSetting": false
                        },
                        {
                          "name": "APPLICATIONINSIGHTS_CONNECTION_STRING",
                          "value": "$(appInsightsConnectionString)",
                          "slotSetting": false
                        },
                        {
                          "name": "AllowedOrigins",
                          "value": "https://$(uiWebAppName).azurewebsites.net",
                          "slotSetting": false
                        }
                      ]
                
                - bash: |
                    echo "========================================"
                    echo "Production API Health Check"
                    echo "========================================"
                    
                    API_URL="https://$(apiWebAppName).azurewebsites.net"
                    HEALTH_URL="$API_URL/health"
                    
                    echo "API URL: $API_URL"
                    echo "Health Endpoint: $HEALTH_URL"
                    echo ""
                    echo "⏳ Waiting 90 seconds for application to fully initialize..."
                    sleep 90
                    
                    echo ""
                    echo "Starting health checks..."
                    
                    MAX_ATTEMPTS=12
                    ATTEMPT=1
                    WAIT_BETWEEN_ATTEMPTS=15
                    
                    while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
                      echo ""
                      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                      echo "Attempt $ATTEMPT/$MAX_ATTEMPTS"
                      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                      
                      # Try health endpoint with verbose output
                      echo "Testing /health endpoint..."
                      HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" -m 15 $HEALTH_URL)
                      
                      echo "HTTP Status Code: $HTTP_CODE"
                      
                      # Handle different status codes
                      if [ $HTTP_CODE -eq 200 ]; then
                        echo ""
                        echo "✅ SUCCESS! API Health Check Passed!"
                        echo "Response:"
                        cat /tmp/health_response.txt
                        echo ""
                        exit 0
                      
                      elif [ "$HTTP_CODE" = "000" ]; then
                        echo "⚠️  Connection failed (000) - App may still be starting"
                        
                        # Check if we can reach the root endpoint
                        echo "Checking root endpoint as fallback..."
                        ROOT_CODE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 $API_URL)
                        echo "Root endpoint status: $ROOT_CODE"
                        
                        if [ "$ROOT_CODE" != "000" ]; then
                          echo ""
                          echo "ℹ️  API is responding at root but /health endpoint not available"
                          
                          # If we're past attempt 6, accept this as success
                          if [ $ATTEMPT -ge 6 ]; then
                            echo "✅ Accepting deployment - API is accessible"
                            exit 0
                          fi
                        else
                          echo "❌ Root endpoint also unreachable"
                        fi
                      
                      elif [ $HTTP_CODE -eq 503 ]; then
                        echo "⚠️  Service Unavailable (503) - App is starting up"
                      
                      elif [ $HTTP_CODE -eq 404 ]; then
                        echo "⚠️  Not Found (404) - /health endpoint may not exist"
                        echo "ℹ️  If your API doesn't have a /health endpoint, this is expected"
                        
                        # Check root to verify app is running
                        ROOT_CODE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 $API_URL)
                        if [ "$ROOT_CODE" = "200" ] || [ "$ROOT_CODE" = "404" ]; then
                          echo "✅ API is running (root returned $ROOT_CODE)"
                          exit 0
                        fi
                      
                      elif [ $HTTP_CODE -ge 200 ] && [ $HTTP_CODE -lt 300 ]; then
                        echo "✅ Success! Non-200 but successful status: $HTTP_CODE"
                        exit 0
                      
                      else
                        echo "⚠️  Unexpected status code: $HTTP_CODE"
                        if [ -f /tmp/health_response.txt ]; then
                          echo "Response body:"
                          cat /tmp/health_response.txt | head -10
                        fi
                      fi
                      
                      # Wait before next attempt
                      if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                        echo ""
                        echo "⏳ Waiting $WAIT_BETWEEN_ATTEMPTS seconds before retry..."
                        sleep $WAIT_BETWEEN_ATTEMPTS
                      fi
                      
                      ATTEMPT=$((ATTEMPT + 1))
                    done
                    
                    echo ""
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    echo "❌ HEALTH CHECK FAILED"
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    echo "The API did not become healthy after $MAX_ATTEMPTS attempts"
                    echo ""
                    echo "Please check:"
                    echo "1. Azure Portal: App Service logs"
                    echo "2. Application Insights: Exceptions/errors"
                    echo "3. Verify /health endpoint exists in your API"
                    echo ""
                    exit 1
                  displayName: 'API Health Check'
                  continueOnError: false
      
      - deployment: DeployProdUI
        displayName: 'Deploy UI to Production'
        dependsOn: DeployProdAPI
        condition: succeeded()
        environment: 'production'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: ui-drop
                  displayName: 'Download UI Artifacts'
                
                - task: ExtractFiles@1
                  displayName: 'Extract UI Build'
                  inputs:
                    archiveFilePatterns: '$(Pipeline.Workspace)/ui-drop/ui-build.zip'
                    destinationFolder: '$(Pipeline.Workspace)/ui-extracted'
                    cleanDestinationFolder: true
                
                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy UI to Azure App Service'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    appType: 'webAppLinux'
                    WebAppName: '$(uiWebAppName)'
                    packageForLinux: '$(Pipeline.Workspace)/ui-extracted'
                    RuntimeStack: 'NODE|18-lts'
                
                - task: AzureAppServiceSettings@1
                  displayName: 'Configure UI App Settings'
                  inputs:
                    azureSubscription: 'Azure-School-Management'
                    appName: '$(uiWebAppName)'
                    resourceGroupName: '$(resourceGroup)'
                    appSettings: |
                      [
                        {
                          "name": "REACT_APP_API_URL",
                          "value": "https://$(apiWebAppName).azurewebsites.net",
                          "slotSetting": false
                        },
                        {
                          "name": "WEBSITE_NODE_DEFAULT_VERSION",
                          "value": "~18",
                          "slotSetting": false
                        }
                      ]
                
                - bash: |
                    sleep 20
                    UI_URL="https://$(uiWebAppName).azurewebsites.net"
                    HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $UI_URL)
                    if [ $HTTP_CODE -eq 200 ]; then
                      echo "✅ UI is accessible!"
                    else
                      echo "⚠️ UI returned status: $HTTP_CODE"
                    fi
                  displayName: 'UI Smoke Test'
                
                - bash: |
                    echo "========================================"
                    echo "✅ PRODUCTION DEPLOYMENT COMPLETE!"
                    echo "========================================"
                    echo "API: https://$(apiWebAppName).azurewebsites.net"
                    echo "UI: https://$(uiWebAppName).azurewebsites.net"
                    echo "========================================"
                  displayName: 'Deployment Summary'